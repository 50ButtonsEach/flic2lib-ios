//
//  FLICEnums.h
//  fliclib
//
//  Created by Anton Meier on 2019-04-18.
//  Copyright Â© 2020 Shortcut Labs. All rights reserved.
//

#ifndef FLICEnums_h
#define FLICEnums_h

extern NSString * const FLICErrorDomain;
extern NSString * const FLICButtonScannerErrorDomain;

/*!
 * @enum FLICManagerState
 *
 * @discussion      Represents the the different states that a Flic manager can be in at any given time. These states are mostly translated values of Apple's CoreBluetooth CBManagerState enums.
 *
 */
typedef NS_ENUM(NSInteger, FLICManagerState)
{
    /**
     * State is unknown, update imminent.
     */
    FLICManagerStateUnknown = 0,
    /**
     * The bluetooth connection with the system service was momentarily lost, update imminent.
     */
    FLICManagerStateResetting,
    /**
     * The Flic manager can not be used on this platform.
     */
    FLICManagerStateUnsupported,
    /**
     * The application is not authorized to use Bluetooth Low Energy.
     */
    FLICManagerStateUnauthorized,
    /**
     * Bluetooth is currently powered off.
     */
    FLICManagerStatePoweredOff,
    /**
     * Bluetooth is currently powered on and available to use.
     */
    FLICManagerStatePoweredOn
};

/*!
 * @enum FLICButtonScannerErrorCode
 *
 * @discussion      Represents the different error codes that can be generated while scanning and pairing new Flics.
 *
*/
typedef NS_ENUM(NSInteger, FLICButtonScannerErrorCode)
{
    /**
     * The scan was unsuccessful due to an unknown reason.
     */
    FLICButtonScannerErrorCodeUnknown = 0,
    /**
     * The scan could not be started since bluetooth was not in the powered on state.
     */
    FLICButtonScannerErrorCodeBluetoothNotActivated,
    /**
     * No button was advertising in public mode within proximity.
     */
    FLICButtonScannerErrorCodeNoPublicButtonDiscovered,
    /**
     * The bluetooth pairing failed since the user already has paired this button before with this device.
     * This is solved by removing the pairing from the iOS bluetooth pairing settings screen.
     */
    FLICButtonScannerErrorCodeBLEPairingFailedPreviousPairingAlreadyExisting,
    /**
     * The bluetooth pairing failed since the user pressed cancel on the pairing dialog.
     */
    FLICButtonScannerErrorCodeBLEPairingFailedUserCanceled,
    /**
     * The bluetooth pairing failed since iOS decided to decline the request. It is unknown why or if this can happen.
     */
    FLICButtonScannerErrorCodeBLEPairingFailedUnknownReason,
    /**
     * Indicates that the button cannot be unlocked since it belongs to a different brand.
     */
    FLICButtonScannerErrorCodeAppCredentialsDontMatch,
    /**
     * The scan was manually canceled using the stopScan method.
     */
    FLICButtonScannerErrorCodeUserCanceled,
    /**
     * The Flic's certificate belongs to a different bluetooth address.
     */
    FLICButtonScannerErrorCodeInvalidBluetoothAddress,
    /**
     * The framework was unable to pair with the Flic since it did not pass the authenticity check.
     */
    FLICButtonScannerErrorCodeGenuineCheckFailed,
    /**
     * The discovered Flic cannot be connected since it is currently connected to a different device.
     */
    FLICButtonScannerErrorCodeAlreadyConnectedToAnotherDevice,
    /**
     * The discovered Flic cannot be connected since the maximum number of simultaneous app connections has been reached.
     */
    FLICButtonScannerErrorCodeTooManyApps,
    /**
     * A bluetooth specific error. The framework was unable to establish a connection to the Flic peripheral.
     */
    FLICButtonScannerErrorCodeCouldNotSetBluetoothNotify,
    /**
     * A bluetooth specific error. The framework was unable to establish a connection to the Flic peripheral.
     */
    FLICButtonScannerErrorCodeCouldNotDiscoverBluetoothServices,
    /**
     * The bluetooth connection was dropped during the verification process.
     */
    FLICButtonScannerErrorCodeButtonDisconnectedDuringVerification,
    /**
     * The Flic peripheral connection was unexpectedly lost.
     */
    FLICButtonScannerErrorCodeConnectionTimeout,
    /**
     * The bluetooth connection failed.
     */
    FLICButtonScannerErrorCodeFailedToEstablish,
    /**
     * The iOS device reached the maximum number of allowed bluetooth peripherals.
     */
    FLICButtonScannerErrorCodeConnectionLimitReached,
    /**
     * The signature generated by the Flic button could not be verified.
     */
    FLICButtonScannerErrorCodeInvalidVerifier,
    /**
     * The Flic button was no longer in public mode when the verification process ran.
     */
    FLICButtonScannerErrorCodeNotInPublicMode,
};

/*!
 * @enum FLICButtonScannerStatusEvent
 *
 * @discussion      While the scanner is running, it will send a status events to let you know what it is doing. These enums represents those events.
 *
*/
typedef NS_ENUM(NSInteger, FLICButtonScannerStatusEvent)
{
    /**
     * A public Flic has been discovered and a connection attempt will now be made.
     */
    FLICButtonScannerStatusEventDiscovered = 0,
    /**
     * The Flic was successfully bluetooth connected.
     */
    FLICButtonScannerStatusEventConnected,
    /**
     * The Flic has been verified and unlocked for this app. The Flic will soon be delivered in the assigned completion handler.
     */
    FLICButtonScannerStatusEventVerified,
    /**
     * The Flic could not be verified. The completion handler will soon run to let you know what the error was.
     */
    FLICButtonScannerStatusEventVerificationFailed,
};

/*!
 *  @enum FLICError
 *
 *  @discussion     These enums represents the different error codes that can be sent from flic2lib, excluding the button scanner which has its own set of error codes.
 *
 */
typedef NS_ENUM(NSInteger, FLICError)
{
    /**
     * An unknown error has occurred.
     */
    FLICErrorUnknown = 0,
    /**
     * You are trying to use the manager while it has not been configured yet.
     */
    FLICErrorNotConfigured,
    /**
     * A bluetooth specific error code. This means that something went wrong while the phone tried to establish a connection with the Flic peripheral.
     */
    FLICErrorCouldNotDiscoverBluetoothServices,
    /**
     * The framework was unable to verify the cryptographic signature from the Flic while setting up a session.
     */
    FLICErrorVerificationSignatureMismatch,
    /**
     * The UUID of a button is not correct.
     */
    FLICErrorInvalidUuid,
    /**
     * While establishing a connection with the Flic the framework was unable to verify the authenticity of the button.
     */
    FLICErrorGenuineCheckFailed,
    /**
     * The app was unable to establish a connection with the Flic button because it already had a connection with too many apps on this particular phone.
     */
    FLICErrorTooManyApps,
    /**
     * The pairing on the Flic button has been lost so the app's pairing data is no longer valid. This typically happens if the Flic is factory reset.
     */
    FLICErrorUnpaired,
    /**
     * The manager was unable to complete the task since the device is not running on a supported iOS version.
     */
    FLICErrorUnsupportedOSVersion,
    /**
     * You are trying to use a FLICButton object that has already been forgotten by the manager. Please discard of your references to this object.
     */
    FLICErrorAlreadyForgotten,
};

/*!
 *  @enum FLICButtonState
 *
 *  @discussion     The different states that a Flic can be in at any given time.
 *
 */
typedef NS_ENUM(NSInteger, FLICButtonState)
{
    /**
     * The Flic is currently disconnected and a pending connection is not set. The Flic will not connect again unless you manually call the connect method.
     */
    FLICButtonStateDisconnected = 0,
    /**
     * The Flic is currently disconnected, but a pending connection is set. The Flic will automatically connect again as soon as it becomes available.
     */
    FLICButtonStateConnecting,
    /**
     * The Flic currently has a bluetooth connection with the phone. This does not necessarily mean that it has been verified.
     * Please listen for the isReady event, or read the isReady property, for that information
     */
    FLICButtonStateConnected,
    /**
     * The Flic is currently connected, but is attempting to disconnect. Typically this state will only occur for very short periods of time before either switching to
     * the connecting or disconnected state again.
     */
    FLICButtonStateDisconnecting,
};

/*!
 *  @enum FLICButtonTriggerMode
 *
 *  @discussion     The different trigger modes that you can configure the Flic button to use. Please make sure that you understand how these work.
 *                  The choosen trigger mode will affect the latency on the press events coming from the Flic button.
 *
 */
typedef NS_ENUM(NSInteger, FLICButtonTriggerMode)
{
    /**
     * Used to distinguish between only click and hold.
     *
     * Click will be fired when the button is released if it was pressed for maximum 1 second.
     * Otherwise, hold will be fired 1 second after the button was pressed. Click will then not be fired upon release.
     * Since this option will only distinguish between click and hold it does not have to take double click into consideration.
     * This means that the click event can be sent immediately on button release rather than to wait for a possible double click.
     *
     * Note: this will be the default behavior.
     */
    FLICButtonTriggerModeClickAndHold = 0,
    /**
     * Used to distinguish between only single click and double click.
     *
     * Double click will be registered if the time between two button down events was at most 0.5 seconds.
     * The double click event will then be fired upon button release.
     *
     * If the time was more than 0.5 seconds, a single click event will be fired; either directly upon button release if the button was down
     * for more than 0.5 seconds, or after 0.5 seconds if the button was down for less than 0.5 seconds.
     */
    FLICButtonTriggerModeClickAndDoubleClick,
    /**
     * Used to distinguish between single click, double click and hold.
     *
     * If the time between the first button down and button up event was more than 1 second, a hold event will be fired.
     * Else, double click will be fired if the time between two button down events was at most 0.5 seconds.
     * The double click event will then be fired upon button release.
     *
     * If the time was more than 0.5 seconds, a single click event will be fired; either directly upon button release if the button was down
     * for more than 0.5 seconds, or after 0.5 seconds if the button was down for less than 0.5 seconds.
     *
     * Note: Three fast consecutive clicks means one double click and then one single click. Four fast consecutive clicks means two double clicks.
     */
    FLICButtonTriggerModeClickAndDoubleClickAndHold,
    /**
     * This mode will only send click and the event will be sent directly on buttonDown.
     * This will be the same as listening for buttonDown.
     *
     * Note: This is optimal if your application requires the lowest latency possible.
     */
    FLICButtonTriggerModeClick,
};

/*!
 *  @enum FLICButtonTriggerMode
 *
 *  @discussion     The different latency modes that you can configure the Flic button to use.
 *
 */
typedef NS_ENUM(NSInteger, FLICLatencyMode)
{
    /**
     * This is the default mode of the button. It will give you a good compromise between click latency (less than 105 ms while connected) and current consumption.
     */
    FLICLatencyModeNormal = 0,
    /**
     * Using this mode will give your button the lowest possible click latency (typicaly less than 30 ms while connected).
     * This mode will significantly increase the current consumption.
     */
    FLICLatencyModeLow,
};

#endif /* FLICEnums_h */
